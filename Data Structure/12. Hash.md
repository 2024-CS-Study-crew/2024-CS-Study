# 📌 Hash

## 해시테이블 (Hash Table)
> **해시 테이블**은 **(Key, Value)** 로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조이다. 
>
> **해시 테이블**은 키(Key), 해시함수(Hash Function), 해시(Hash), 값(value), 저장소(Bucket, Slot)로 이루어져 있다.  
=> **key**는 **해시함수**를 통해 **해시**로 변경이 되며 해시는 **value**와 매칭되어 저장소에 저장된다.

![](https://velog.velcdn.com/images/jihyun/post/c8b2c0a6-a500-4e8c-bbf5-26e7b96849ab/image.png)

<br>

- **키(key)**
: 고유한 값이며, 해시 함수의 input이 된다. 다양한 길이의 값이 될 수 있다. 이 상태로 최종 저장소에 저장이 되면 다양한 길이 만큼의 저장소를 구성해 두어야 하기 때문에 해시 함수로 값을 바꾸어 저장이 되어야 공간의 효율성을 추구할 수 있다.

- **버킷(Bucket)**
: 해시 테이블 내의 각 슬롯을 버킷이라고 한다. 하나의 버킷에는 하나 이상의 키-값 쌍이 저장될 수 있다.

- **해시함수(Hash Function)**
: 키(key)를 해시(hash)로 바꿔주는 역할을 한다. 다양한 길이를 가지고 있는 키(key)를 일정한 길이를 가지는 해시(hash)로 변경하여 저장소를 효율적으로 운영할 수 있도록 도와준다.

- **해시(Hash)**
: 해시 함수(Hash Function)의 결과물이며, 저장소(bucket, slot)에서 값(value)과 매칭되어 저장된다.

- **값(Value)**
: 저장소(bucket, slot)에 최종적으로 저장되는 값으로 키와 매칭되어 저장, 삭제, 검색, 접근이 가능해야 한다.


---

## 해시테이블 (Hash Table) 특징
- 빠른 검색 속도  
 :  해시 테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 **배열(버킷)** 을 사용하여 데이터를 저장하기 때문이다.
해시 테이블은 각각의 **Key값**에 **해시함수**를 적용해 배열의 고유한 **index**를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다. 여기서 실제 값이 저장되는 장소를 **버킷**이라고 한다.


---
## 해시함수 (Hash Function)
해시 함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것이다. 해시 테이블에 사용되는 대표적인 해시 함수로는 아래의 3가지가 있다. 

- **Division Method**
: 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다. (주소 = 입력값 % 테이블의 크기) 테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.

- **Digit Folding**
: 각 Key의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법이다.

- **Multiplication Method**
: 숫자로 된 Key값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 해준다. h(k)=(kAmod1) × m

- **Univeral Hashing**
: 다수의 해시함수를 만들어 집합 H에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만드는 기법이다.
<br>

---



## 해시충돌 (Hash Collision)
> 서로 다른 키(key)가 같은 해시(hash)가 되는 경우를 **해시 충돌(Hash Collision)** 이라고 한다.
해시함수는 입력 값의 범위보다 출력 값의 범위가 좁은 경우가 많기 때문에 입력 값이 다르더라도 동일한 값이 출력될 수도 있다. 

해시 테이블에서는 충돌에 의한 문제를 크게 2가지로 해결하고 있다.

### 1) 체이닝 (Chaining)

 체이닝은 버킷 내에 연결리스트를 할당하여 데이터를 삽입하다가 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식이다.  
 ![](https://velog.velcdn.com/images/jihyun/post/1f277add-dd17-4969-aaa7-d9cde7e31b37/image.png)

 
-> 버킷이 꽉 차더라도 연결리스트로 계속 늘려가기에, 데이터의 주소값은 바뀌지 않는다. 

-> 연결 리스트만 사용하면 된다. 즉, 복잡한 계산식을 사용할 필요가 개방주소법에 비해 적다.

-> 메모리 오버헤드가 크고, 캐시 효율성이 떨어질 수 있다.

<br>

### 2) 개방 주소법 (Open Addressing)

 개방 주소법은 해시 충돌이 일어나면 다른 버킷에 데이터를 삽입하는 방식이다. 개방 주소법은 대표적으로 3가지가 있다.
- **선형 탐색(Linear Probing)** : 해시충돌 시 다음 버킷, 혹은 몇 개를 건너뛰어 데이터를 삽입한다.

- **제곱 탐색(Quadratic Probing)** : 해시충돌 시 제곱만큼 건너뛴 버킷에 데이터를 삽입한다. (1,4,9,16..)

- **이중 해시(Double Hashing)** : 해시충돌 시 다른 해시함수를 한 번 더 적용한 결과를 이용한다.

![](https://velog.velcdn.com/images/jihyun/post/883e61b0-593c-4eff-a7cc-7c90303bacb5/image.png)  
-> 체이닝처럼 포인터가 필요없고, 지정한 메모리 외 추가적인 저장공간도 필요없다.

-> 삽입,삭제시 오버헤드가 적다.

-> 저장할 데이터가 적을 때 더 유리하다.

-> 삭제가 어렵다. 삭제를 한 경우 충돌에 의해 뒤로 저장된 데이터는 검색이 안될 수 있다.


<br>


 
<br>
해시 충돌을 일으키는 확률을 최대한 줄이는 함수를 만드는 것이 중요하다.



<br>

---

### 해시 사용 사례
- 캐싱
- 데이터베이스 인덱싱
- 중복 검사
<br>

---

### 해시 시간복잡도
- 해시테이블의 평균 시간복잡도는 **O(1)** 이다.
=> 해싱 구조로 데이터를 저장하면 Key값으로 데이터를 찾을 때 해시 함수를 1번만 수행하면 되므로 매우 빠르게 데이터를 저장/삭제/조회할 수 있다. 

- 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야 하므로 **O(N)** 까지 시간복잡도가 증가할 수 있다.


---
