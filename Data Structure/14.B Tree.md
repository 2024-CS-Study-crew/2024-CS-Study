# B Tree

이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞추는 **균형이진트리**의 확장판

### 이진트리

각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 자료구조

![1](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/9d16a6b1-6079-4bae-8bf2-f11f546f4b74)

- 종류
    - **정이진트리** 
    : 트리의 모든 node가 0개 혹은 2개의 자식을 가지는 경우
    - **포화이진트리**
    : leaf node가 끝까지 모두 찬 트리
    - **완전이진트리**
    : 마지막 레벨을 제외한 모든 레벨에서 순서대로 node가 모두 찬 트리
    - **균형이진트리**
    : leaf node들의 레벨 차가 최대 1레벨까지만 나는 트리
    ➡️ 균형이 깨지면 별도의 로직을 통해 다시 균형을 유지하게 된다
    
    ![2](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/f74a4a0f-44f8-4396-95d4-48d5769af6a8)
    

### B-Tree

이진 트리와는 다르게 **하나의 노드에 많은 정보**를 가지거나 **두 개 이상의 자식**을 가질 수 있다

➡️ 최대 M개의 자식을 가질 수있는 B-Tree → M차 B-Tree

![3](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/fb0c6f40-05c9-47e7-922d-2f7530834bdb)

- 특징
    - 하나의 노드에 여러 자료를 배치할 수 있기에 이진 트리보다 훨씬 많은 데이터를 효율적으로 저장소에 담을 수 있다
        
        (하드디스크, SSD 등의 외부 기억 장치는 블럭 단위로 파일을 입출력한다. 
        이때 발생하는 입출력 비용이 파일 크기와 상관없이 동일하기 때문에 
        → 하나의 블럭에 여러 데이터들을 동시에 저장할 수 있다면 블럭을 보다 효율적으로 사용할 수 있다)
        
    - 각 노드의 자료는 정렬되어 있다
    - 자료는 중복되지 않는다
    - 모든 leaf node는 같은 레벨에 있다
    - root node는 자신이 leaf node가 되지 않는 이상 적어도 2개 이상의 자식을 가진다
    - root node와 leaf node를 제외한 노드들은 최소 M/2 ~ 최대 M개까지의 자식을 가질 수 있다
    - 노드의 키는 최소 M/2 - 1 ~ 최대 M-1개가 포함될 수 있다
    - 자식 수의 하한값을 t라고 한다면, M = 2t - 1을 만족한다

- B-Tree 로직 확인
    
    [B-Tree Visualization](https://www.cs.usfca.edu/~galles/visualization/BTree.html)
    

### B*Tree

B-Tree의 단점 (구조를 유지하기 위해 추가적인 연산이 수행되거나 새로운 노드가 생성됨) 을 최소화하기 위해 B-Tree에서 몇 가지 규칙을 추가한 트리

- 차이점
    - 최소 M/2개의 키값을 가져야 했던 기존 노드의 자식 노드 수 최소 제약 조건이 2M/3개로 늘어남
    - 노드가 가득 차면 분열 대신 이웃한 형제 노드로 재배치를 한다 (더이상 재배치를 할 수 없는 시점이 되어서야 분열을 한다.)

- 특징
    - 각 노드의 자료는 정렬되어 있다.
    - 자료는 중복되지 않다.
    - 모든 leaf node는 같은 레벨에 있다.
    - root node는 자신이 leaf node가 되지 않는 이상 적어도 2개 이상의 자식 노드를 가진다.
    - root node가 아닌 노드들은 적어도 2⌈(M-2)/3⌉+1개의 자식 노드를 가지고 있다. (최대 M개)
    

### B+Tree

B-Tree의 단점 (탐색을 위해 노드를 찾아서 이동해야 함) 을 해소하기 위해 같은 레벨의 모든 키 값이 정렬되어 있고, 같은 레벨의 형제 노드는 연결 리스트 형태로 이어져 있는 트리

➡️ 특정 값을 찾아야 한다면 leaf 노드에 모든 자료가 존재하고, 그 자료들이 연결 리스트로 연결되어 있기 때문에 탐색에 매우 유리하다
![5](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/bdeb6e2c-b9b0-491f-bb26-4a7b7c63688a)

- 탐색 과정 예시
    
    ![4](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/6a3dd3c8-7248-49dc-8c5d-d97c830eaf0b)


leaf node가 아닌 자료는 **인덱스 노드**라고 부르고, leaf node 자료는 **데이터 노드**라고 부른다

- 인덱스 노드
Value값에는 다음 노드를 가리킬 수 있는 포인터 주소가 존재한다.
- 데이터 노드
데이터 노드의 Value값에 데이터가 존재한다.

따라서 키 값 중복 가능(인덱스 노드와 데이터 노드에서 동시에 등장 가능)

데이터 검색을 위해서는 반드시 leaf node까지 내려가야 한다

➡️ 오늘날 데이터베이스에서 가장 중요한 것은 검색속도 → 대부분의 데이터베이스 시스템은 B+Tree구조를 채택

- 특징
    - 데이터 노드의 자료는 정렬되어 있다.
    - 데이터 노드에서는 데이터가 중복되지 않는다.
    - 모든 leaf node는 같은 레벨에 있다.
    - leaf node가 아닌 node의 키값의 수는 그 노드의 서브트리수보다 하나가 적다.
    - 모든 leaf node는 연결리스트로 연결되어 있다.
