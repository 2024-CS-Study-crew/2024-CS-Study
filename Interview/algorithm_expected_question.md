# Algorithm

### 1. 해시 테이블의 충돌(Collision) 처리 방법에는 어떤 것들이 있나요?

해시 테이블에서 충돌을 처리하는 방법에는 주로 체이닝과 개방 주소법이 사용된다. 

체이닝은 각 인덱스마다 연결 리스트를 생성하여 충돌하는 데이터를 연결시키는 방식이다. 충돌이 발생하면 해당 인덱스의 연결 리스트에 데이터를 추가하게 된다. 

개방 주소법은 충돌이 발생한 경우 빈 공간을 찾아 데이터를 저장하는 방식이다. 이 외에도 이중 해싱이나 재해싱 등의 충돌 처리 방법이 있다.

<br>

### 2. 비트마스크를 사용하는 것이 다른 자료구조와 비교하여 어떤 장점이 있나요?

첫째, 메모리 사용이 매우 효율적이다. 비트마스크는 0과 1로 이루어져 있으며, 각 비트는 단일 원소의 상태를 나타내므로 메모리 공간을 절약할 수 있다. 

둘째, AND, OR, XOR 등의 비트 연산을 통해 효율적이고 빠른 연산이 가능하다. 

마지막으로, 간결하고 직관적인 코드를 작성할 수 있다. 비트마스크를 사용하면 집합의 포함 여부, 조합 생성 등을 간결하게 표현할 수 있으며, 코드의 가독성을 높일 수 있다.

<br>

### 3. 계수 정렬의 장점은 무엇인가요?

우선, 계수 정렬은 비교 연산을 사용하지 않고 데이터의 출현 빈도를 계수하는 과정만 거치기 때문에 매우 빠른 속도로 정렬할 수 있다. 

또한, 추가적인 공간 복잡도가 상대적으로 낮다. 계수 정렬은 데이터의 출현 빈도를 세기 위한 배열을 사용하는데 이 배열의 크기는 데이터의 범위에 비례하므로, 데이터의 범위가 크지 않은 경우에는 추가적인 공간 복잡도가 낮다고 할 수 있다.

<br>

### 4. 비교하지 않고 배열을 정렬할 수 있는 방법은 무엇인가요?

비교하지 않고 배열을 정렬하는 방법으로는 기수 정렬과 계수 정렬이 있다. 기수 정렬은 낮은 자릿수부터 정렬을 수행한다.  
계수 정렬은 데이터의 범위를 인덱스로 갖는 배열을 생성한 뒤에 데이터 개수를 세는 방법이다.  
두 정렬 방법 모두 비교 정렬 대비 시간 복잡도 측면에서 효율적이지만 메모리가 낭비될 수 있다는 단점이 있다.

<br>

### 5. 동적 계획법(DP, Dynamic Programming)에 대해 설명해주세요.

   주어진 문제를 풀기 위해, 문제를 여러 개의 하위 문제로 나누어 푸는 방법을 말합니다.  
   동적 계획법에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization)기법으로 속도를 향상시킬 수 있습니다.

<br>

### 6. 동적 계획법(DP, Dynamic Programming)이 갖는 2가지 조건은 무엇인가요? 

1. 중복되는 부분(작은) 문제 중복되는 부분 문제는 나눠진 부분 문제가 중복되는 경우로, 메모이제이션 기법을 사용해 중복 계산을 없앱니다.  
2. 최적 부분 구조최적 부분 구조를 가진다는 것은 전체 문제의 최적해가 부분 문제의 최적해들로써 구성된다는 것입니다.

<br>

### 7. 삽입 정렬(Injection Sort)에 대해 설명해주세요.

  삽입 정렬은 두 번째 값부터 시작해 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘입니다.  
  평균 시간복잡도는 O(n^2)이며, Best Case 의 경우 O(n)까지 높아질 수 있습니다.  

<br>

### 8. 퀵 정렬(Quick Sort)에 대해 설명해주세요.

  퀵 정렬은 빠른 정렬 속도를 자랑하는 분할 정복 알고리즘 중 하나로 피봇을 설정하고 피봇보다 큰 값과 작은 값으로 분할하여 정렬 합니다.  
  병합정렬과 달리 리스트를 비균등하게 분할합니다.  
  시간 복잡도는 O(nlogn)이며 worst case 경우 O(n^2)까지 나빠질 수 있습니다.

<br>

### 9. Quick sort 에서 최악의 복잡도 O(n^2) 이 발생하는 경우를 설명하고 이를 개선할 수 있는 방법에 대해서도 추가적으로 설명해주세요
  
  예로 pivot을 가장 큰 값이나 작은 값으로 잡는 경우 분할 과정에서 비대칭적인 파티션이 반복되며 시간복잡도가 O(n^2)이 됩니다.  
  이 경우 수행시간이 일반적인 경우보다 훨씬 길어지게 되는데 이를 개선하기 위해서는 난수를 발생시켜 피벗을 랜덤하게 뽑는 방법이 있습니다.

<br>

