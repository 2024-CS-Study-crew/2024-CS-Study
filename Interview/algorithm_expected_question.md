# Algorithm

### 1. 해시 테이블의 충돌(Collision) 처리 방법에는 어떤 것들이 있나요?

해시 테이블에서 충돌을 처리하는 방법에는 주로 체이닝과 개방 주소법이 사용된다. 

체이닝은 각 인덱스마다 연결 리스트를 생성하여 충돌하는 데이터를 연결시키는 방식이다. 충돌이 발생하면 해당 인덱스의 연결 리스트에 데이터를 추가하게 된다. 

개방 주소법은 충돌이 발생한 경우 빈 공간을 찾아 데이터를 저장하는 방식이다. 이 외에도 이중 해싱이나 재해싱 등의 충돌 처리 방법이 있다.

<br>

### 2. 비트마스크를 사용하는 것이 다른 자료구조와 비교하여 어떤 장점이 있나요?

첫째, 메모리 사용이 매우 효율적이다. 비트마스크는 0과 1로 이루어져 있으며, 각 비트는 단일 원소의 상태를 나타내므로 메모리 공간을 절약할 수 있다. 

둘째, AND, OR, XOR 등의 비트 연산을 통해 효율적이고 빠른 연산이 가능하다. 

마지막으로, 간결하고 직관적인 코드를 작성할 수 있다. 비트마스크를 사용하면 집합의 포함 여부, 조합 생성 등을 간결하게 표현할 수 있으며, 코드의 가독성을 높일 수 있다.

<br>

### 3. 계수 정렬의 장점은 무엇인가요?

우선, 계수 정렬은 비교 연산을 사용하지 않고 데이터의 출현 빈도를 계수하는 과정만 거치기 때문에 매우 빠른 속도로 정렬할 수 있다. 

또한, 추가적인 공간 복잡도가 상대적으로 낮다. 계수 정렬은 데이터의 출현 빈도를 세기 위한 배열을 사용하는데 이 배열의 크기는 데이터의 범위에 비례하므로, 데이터의 범위가 크지 않은 경우에는 추가적인 공간 복잡도가 낮다고 할 수 있다.

<br>

### 4. 비교하지 않고 배열을 정렬할 수 있는 방법은 무엇인가요?

비교하지 않고 배열을 정렬하는 방법으로는 기수 정렬과 계수 정렬이 있다. 기수 정렬은 낮은 자릿수부터 정렬을 수행한다.  
계수 정렬은 데이터의 범위를 인덱스로 갖는 배열을 생성한 뒤에 데이터 개수를 세는 방법이다.  
두 정렬 방법 모두 비교 정렬 대비 시간 복잡도 측면에서 효율적이지만 메모리가 낭비될 수 있다는 단점이 있다.

<br>

### 5. 동적 계획법(DP, Dynamic Programming)에 대해 설명해주세요.

주어진 문제를 풀기 위해, 문제를 여러 개의 하위 문제로 나누어 푸는 방법을 말합니다.  
동적 계획법에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization)기법으로 속도를 향상시킬 수 있습니다.

<br>

### 6. 동적 계획법(DP, Dynamic Programming)이 갖는 2가지 조건은 무엇인가요? 

1. 중복되는 부분(작은) 문제 중복되는 부분 문제는 나눠진 부분 문제가 중복되는 경우로, 메모이제이션 기법을 사용해 중복 계산을 없앱니다.  
2. 최적 부분 구조최적 부분 구조를 가진다는 것은 전체 문제의 최적해가 부분 문제의 최적해들로써 구성된다는 것입니다.

<br>

### 7. 삽입 정렬(Injection Sort)에 대해 설명해주세요.

삽입 정렬은 두 번째 값부터 시작해 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘입니다.  
평균 시간복잡도는 O(n^2)이며, Best Case 의 경우 O(n)까지 높아질 수 있습니다.  

<br>

### 8. 왜 삽입 정렬이 평균 O(2) 시간복잡도를 갖는 알고리즘 중 가장 빠를까요?

삽입 정렬은 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘 입니다.  
따라서 삽입할 위치까지만 탐색하면 되기 때문에 선택 정렬과 버블 정렬에 비해 빠릅니다.  
또한, 삽입 정렬은 데이터가 모두 정렬된 경우 한 번씩만 비교하면 되므로 O(N)의 시간복잡도를 갖습니다.

<br>

### 9. 퀵 정렬(Quick Sort)에 대해 설명해주세요.

  퀵 정렬은 빠른 정렬 속도를 자랑하는 분할 정복 알고리즘 중 하나로 피봇을 설정하고 피봇보다 큰 값과 작은 값으로 분할하여 정렬 합니다.  
  병합정렬과 달리 리스트를 비균등하게 분할합니다.  
  시간 복잡도는 O(nlogn)이며 worst case 경우 O(n^2)까지 나빠질 수 있습니다.

<br>

### 10. Quick sort 에서 최악의 복잡도 O(n^2) 이 발생하는 경우를 설명하세요.
  
  예로 pivot을 가장 큰 값이나 작은 값으로 잡는 경우 분할 과정에서 비대칭적인 파티션이 반복되며 시간복잡도가 O(n^2)이 됩니다.  
  이 경우 수행시간이 일반적인 경우보다 훨씬 길어지게 되는데 이를 개선하기 위해서는 난수를 발생시켜 피벗을 랜덤하게 뽑는 방법이 있습니다.

<br>

### 11. Quick sort 성능 개선 기법으로는 어떤게 있나요?

1. 난수를 발생시켜 피벗을 랜덤하게 뽑는 방법이 있습니다.   
2. 맨 앞과 중간, 맨 뒤 값을 우선적으로 정렬하고 중앙값을 피벗으로 삼는 방법입니다.
   
하지만, 이 방법으로 개선한다해도 Quick Sort의 최악의 시간복잡도가 O(nlogn)이 되지는 않습니다.

<br>

### 12. 퀵 정렬을 여러 언어의 정렬 내부 구현으로 사용하는 이유는?

피벗을 적절하게 선택하도록 구현해 성능 개선을 할 수 있고, 퀵 정렬을 수행할 때 한 번 위치가 정해진 원소는 정렬을 위해 확인할 대상이 된다는 특성이 있기 때문에 평균적으로 병합 정렬보다 더 빠른 정렬 알고리즘이기 때문입니다.

<br>

### 13. 안정 정렬인 정렬에는 무엇이 있나요?

삽입 정렬, 버블 정렬, 병합 정렬, 계수 정렬이 안정 정렬에 속합니다.

<br>


### 14. BFS와 DFS와 다익스트라 구현 방법은?

• BFS는 큐를 이용해 구현합니다. 큐에 시작 노드를 넣고, 그래프에서 인접한 노드를 모두 큐에 넣습니다. 그리고 하나씩 꺼내서 반복 합니다.  
  
• DFS는 스택이나 재귀함수를 이용해 구현합니다. 스택에 시작 노드를 넣고, 인접한 노드를 모두 스택에 넣습니다. 그리고 하나를 꺼내서 반복 합니다.  
  
• 다익스트라는 힙을 이용해 구현할 수 있습니다. 최단 거리 테이블을 만들고, 힙에 시작 노드를 넣습니다. 힙에서 최단 거리의 노드를 꺼내고 해당 노드를 거쳐 다른 노드로 이동하는 거리가 더 짧은 경우 최단 거리를 갱신하고, 이동 가능한 노드를 힙에 다시 넣습니다. 이를 힙이 빌 때 까지 반복하면서 최단 거리 테이블을 갱신합니다.

<br>

### 15. DP와 분할정복의 공통점과 차이점은?

DP와 분할정복 모두 문제를 잘게 나누어서, 가장 작은 단위로 분할하여 문제를 해결하는 알고리입니다. 
하지만 DP는 부분 문제가 중복되어 재활용하므로 Memoization이 필요하지만 분할정복에서는 부분 문제가 중복되지 않습니다.

<br>

