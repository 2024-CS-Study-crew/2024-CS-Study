## 📌 교착상태란?
> **교착상태**란 두 개 이상의 프로세스가 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며, **서로의 작업을 끝나기만을 기다리며 둘 다 영원히 끝나지 않는 상황**을 뜻한다.

**🍽️ 식사하는 철학자 문제**

식사하는 철학자 문제는 교착 상태를 설명하기 위한 고전적인 문제이다. 
동그란 원탁에는 다섯 명의 철학자가 앉아있고, 모든 철학자의 앞에는 각각 음식 접시가 놓여있다. 
그리고 식사를 하기 위한 포크는 철학자 사이에 하나씩 총 5개의 포크가 놓여있다.  

![](https://velog.velcdn.com/images/jihyun/post/080a3de6-454c-496a-99b5-af0e409f8c27/image.png)


만약 포크 두 개가 있어야 먹을 수 있는 식사이고, 철학자들은 아래와 같이 식사를 한다고 하자.

① 철학자들은 계속 생각을 하다가 왼쪽 포크가 사용 가능하면 집어든다.  
② 철학자들은 계속 생각을 하다가 오른쪽 포크가 사용 가능하면 집어든다.  
③ 양쪽 포크를 모두 집어 들면 정해진 시간 동안 식사를 한다.  
④ 식사 시간이 끝나면 오른쪽 포크를 내려놓는다.  
⑤ 오른쪽 포크를 내려놓았다면 왼쪽 포크도 내려놓는다.  
⑥ 다시 ①로 돌아간다.

①번을 모든 철학자가 동시에 실행하여 각자 자신의 왼쪽에 있는 포크를 집어 들었다면, 오른쪽에 포크가 남아있는 철학자는 아무도 남지 않는다. 그러면 모든 철학자는 자신의 오른쪽 철학자가 포크를 내려놓을 때까지 집어든 왼쪽 포크를 내려놓지 않을 것이고, 그렇게 **일어나지 않을 사건을 기다리면서 진행이 멈춘 현상**을 교착 상태라고 한다.
<br>

---

## 📌 교착상태의 발생 조건 4가지

교착상태는 아래의 4가지 조건이 모두 만족되는 경우(필요충분조건)에 발생할 가능성이 있으며,
하나라도 만족하지 않으면 교착상태가 발생하지 않는다.

 
**1. 상호 배제(Mutual Exclusion)**
한 번에 한 개의 프로세스만이 공유자원을 사용할 수 있음

**2. 점유 대기(Hold and Wait)**
프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림

**3. 비선점(No Preemption)**
프로세스가 작업을 마친 후 자원을 자발적으로 반환할 때까지 기다림
(이미 할당된 자원을 강제적으로 빼앗을 수 없음)

**4. 순환 대기(Circular Wait)**
프로세스의 자원 점유 및 점유된 자원의 요구 관계가 원형을 이루면서 대기하는 조건.
각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있음
<br>

---

## 📌  교착상태 해결방법

### 🔍 예방(Prevention)
교착상태 예방 방법은 교착상태가 애초에 일어나지 않도록 방지하는 방법으로 교착상태의 발생조건 4가지 중 하나를 부정함으로써 교착상태를 예방하는 방법이다.

**1. 상호 배제 부정**  
여러 개의 프로세스가 동시에 공유자원을 사용할 수 있음

**2. 점유 대기 부정**  
프로세스가 실행되기 전에 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나, 자원이 점유되지 않은 상태에서만 자원 요청을 받도록 함

**3. 비선점 부정**  
모든 자원에 대한 선점을 허용

**4. 순환 대기 부정**  
자원을 선형으로 분류하여 고유 번호를 할당하고, 각 프로세스는 현재 점유한 자원의 고유번호보다 앞이나 뒤 한쪽 방향으로만 자원을 요구하도록 한다.

그러나 이렇게 교착상태 발생조건을 방지해서 데드락을 예방하는 방법은 시스템 처리량이나 자원 사용의 효율성을 떨어트리는 단점이 있다.


---

### 🔍 회피(Avoidance)
교착 상태를 회피하는 것으로, 무분별한 자원 할당이 문제의 원인으로 보고 자원을 조금씩만 할당하는 방법이다.  교착 상태가 발생하지 않는 수준의 상태를 `안전 상태(safe state)`라고 하고, 교착 상태가 발생할 수도 있는 상황을 `불안전 상태(unsafe state)`라고 한다.  이 기준은 안전 순서열(safe sequence)라고 부르는 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서가 있는지에 따라 판단한다.

<br>

교착상태를 회피하기 위한 알고리즘으로 크게 두 가지가 있다.

**🔑 은행원 알고리즘**

은행원 알고리즘이란 '최소한 고객 한 명에게 대출해줄 금액은 항상 은행이 보유하고 있어야 한다'라는 개념에서 나온다. 해당 알고리즘은 교착 상태에 빠질 가능성이 있는지 판단하기 위해 상태를 안전 상태와 불안전 상태로 나누고, 안전 상태를 유지할 수 있는 요구만을 수락하고, 불안전 상태를 초래할 수 있는 사용자의 요구는 만족될 수 있을 때까지 계속해서 거절하는 방법이다.



=> [만화로 설명하는 은행원 알고리즘](https://velog.io/@minu-j/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A7%8C%ED%99%94%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%EC%9D%80%ED%96%89%EC%9B%90-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%9A%8C%ED%94%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)


<br>

**🔑 자원 할당 그래프 알고리즘**

자원 할당 그래프에 예약 간선을 추가하여 예약 간선으로 설정한 자원에 대해서만 자원 할당을 요청할 수 있고 사이클이 형성되지 않을 때만 자원을 할당받는 방법이다.

`자원 할당 그래프` : 프로세스가 어떤 자원을 사용 중이고, 어떤 자원을 기다리는지 방향성 있는 그래프로 표시한 것

`예약 간선` : 향후 요청할 수 있는 자원을 가리키는 점선으로 표시된 간선


---

### 🔍 탐지(Detection)
말 그대로 시스템에 데드락이 발생했는지에 대한 여부를 탐색하고 회복 기법 알고리즘에 활용하는 것을 의미한다. 교착상태가 탐지되었다면 회복 기법을 통해 교착상태를 복구한다.

그러나 탐지 기법은 지속적으로 교착상태를 확인하는 작업이 필요하기 때문에 오버헤드(성능 저하)가 발생한다.

---

### 🔍 회복(Recovery)

**1. 선점을 통한 회복**  
교착 상태가 해결될 때까지 다른 프로세스로부터 자원을 강제로 빼앗아 한 프로세스씩 자원을 몰아주어(선점) 해결하는 방법이 있다.

**2. 프로세스 강제 종료를 통한 회복**  
가장 단순하면서 확실한 방법으로는 교착 상태가 없어질 때까지 교착 상태에 놓인 모든 프로세스 전체 또는 하나씩 강제로 종료하는 방법이다. 단, 전체를 종료할 경우엔 많은 작업 내역을 잃는다는 단점이, 하나씩 종료할 경우엔 교착 상태가 없어졌는지 확인하는 과정에서 오버헤드를 야기한다는 단점이 있다.

**3. 타조 알고리즘**  
교착 상태를 완전히 무시하는 방법으로 타조 알고리즘(orstrich algorithm)이 있다. 문제의 발생 빈도나 심각성에 따라 최대 효율을 추구하는 엔지니어 입장에서는 이 방법이 적합할 때도 많다.


<br>

---


