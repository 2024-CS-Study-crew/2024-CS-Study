### 📌 DP 알고리즘이란?
> 동적계획법이란, 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말한다. 이것은 부분 문제 반복과 최적 부분 구조를 가지고 있는 알고리즘을 일반적인 방법에 비해 더욱 적은 시간을 내어 풀 때 사용한다. 


코딩테스트의 단골 문제로 출제되고 있기에 필수적으로 알아야하는 개념 중 하나이다. 간혹 제약사항에 주어지는 숫자의 범위가 크고, 경우의 수가 엄청 많은 문제들이 대부분 DP를 활용하여 풀어야 하는 문제이다.


<br>

###  📌 DP 알고리즘 사용 조건
동적계획법을 사용하기 위한 조건에는 아래와 같은 두 가지가 있다.

	[조건 1] '부분 반복 문제 (Overlapping Subproblem)'일 것
	[조건 2] '최적 부분 구조(Optimal Substructure)'일 것

<br>

**[ 부분 반복 문제 ]**  
DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 그래서 동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능하다.  
![](https://velog.velcdn.com/images/jihyun/post/0afbb2ed-fc17-44ed-b8a8-f4ffa556ad67/image.png)

7번째 값을 구하기 위해서는 총 25번의 함수가 호출된다는 것을 알 수 있다. 이 과정에서 fibo(5), fibo(4), fibo(3)들이 이미 진행했던 연산임에도 불구하고 재귀되며 반복적으로 연산하는 것을 볼 수 있다.
이러한 반복적인 연산을 부분 반복 문제라고 한다. 


DP는 부분 문제의 결과를 저장하여 다시 계산하지 않아도 되게끔 하는 알고리즘이므로 부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능하니 이러한 경우에는 사용할 수 없다

<BR>

**[ 최적 부분 구조 ]**  
최적 부분 구조란 작은 부분 문제에서 구한 최적의 답으로, 합쳐진 큰 문제의 최적의 답을 구할 수 있어야 한다는 것이다.  
![](https://velog.velcdn.com/images/jihyun/post/4e4626c5-3775-442e-8e47-3a7d510d9635/image.png)

예를 들어 A-X-B로 이어진 길이 있을 때 A-X의 최단 거리와 X-B의 최단 거리를 합했을 때가 A-B 의 최단거리가 되는 것이다.  
```python
  fibo(n) = fibo(n-1) + fibo(n-2)
```
큰 문제의 답인 fibo(n) 이 최적의 답이 되려면, 작은 부분의 문제인 fibo(n-1), fibo(n-2)이 최적의 답이어야만 한다.   
  
여기서, fibo(n-1)을 구하기 위해서는 다시 fibo(n-2) + fibo(n-3)이 되어 fibo(n-2)가 중복되게 된다. 이렇게 중복되는 연산과정을 줄이기 위해서 Memoization을 사용한다. 그리고 최적 부분 구조를 만족한다면 문제의 크기에 상관없이 fibo(n-1)은 언제나 일정한 값을 가진다. 작은 부분의 문제의 최적의 답으로 큰 문제의 최적의 답을 구한다는 뜻이다.

 
  
<br> 

### 📌 Memoization(메모이제이션)
  
Memoization(메모이제이션)은 동일한 계산을 반복해야할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 속도를 빠르게 하는 기술이다. 
  
즉, 메모리에 계산한 값을 저장해 나감으로써 반복 수행될 때 연산 없이 저장된 값을 사용한다는 개념이다.
  
<br>

### 📌 DP 알고리즘 구현 방식
  
**Bottom-Up**  
말 그대로, 아래서 위로 접근하는 방법으로 부분 문제에서부터 문제를 해결하여 점차 큰 문제를 풀어가는 방식이다. for 문을 이용하는 방식이 이에 해당한다. 
  
  테이블에 저장된 값을 직접 접근해 재활용하기 때문에, 반복하며 DP[k]를 채우는 과정을 'table filling'이라 한다.
  
**Top-Down**  
 위에서 아래로 접근하는 방법으로, 큰 문제에서 부분 문제로 쪼개가면서 재귀 호출을 통해 문제를 푸는 방법이다.
  
최종 답인 DP[N]을 구하기 위해 위에서 부터 바로 호출을 시작하여 DP[0]의 상태까지 내려간 다음 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식이다. 피보나치 수열을 구하는 예가 해당한다.
  
<br>

### 📌 DP 알고리즘 구현 단계

1. 문제를 하위 문제로 쪼갠다.
2. 하위 문제를 재귀적으로 해결한다.
3. 결과를 저장한다. (메모이제이션)
4. 저장된 결과를 이용하여 큰 문제를 해결한다.

=> 해당 단계를 통해서 중복 계산을 피하여 성능을 높인다.


<br>
  
